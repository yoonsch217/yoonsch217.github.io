---
layout: default
title: L4
nav_order: 2
parent: network
---

## L4

https://www.youtube.com/watch?v=aS8GvBSQmvo

많은 사용자가 한 번에 접속하면 캐파가 안 받쳐줄 수 있는데 스케일업하기가 쉽지가 않다.
L4 스위치를 통해 HA, Load Balancing을 할 수 있다.
end host 부하 분산을 위한 다중화 목적

자신의 인터페이스로 오는 프레임을 받아 L2 이더넷 헤더를 제거하고, L3 IP 헤더도 제거하고 L4 헤더를 봐서 어디로 어떻게 보낼지를 결정한다.
적합한 L2~L4 헤더까지 완성해서 전달한다.
L4 헤더도 핸들링할 수 있고 L2 헤더도 핸들링할 수 있다.
포트정보까지 바꿀 수 있다.
들어오는 헤더는 B 호스트의 80 포트인데 L4에서 D 호스트의 8080포트라고 바꿀 수 있다.
VIP를 L4가 들고 있다.

호스트 A가 호스트 B에 요청을 한다고 할 때 L4가 호스트B의 역할을 하고 요청을 받는다.
실제로 요청을 처리하는 건 호스트C, D이다. L4가 헤더를 바꿔서 적합한 호스트에게 전달을 한다.

![image](https://media.oss.navercorp.com/user/17362/files/ca465100-655a-11eb-8ca5-bc64f192a07d)

Session table로 동작을 한다.
들어오는 정보에 따라 매핑을 시켜주는 것이다. 그래서 end와 end가 서로 통신하고 있다고 믿게 만드는 것이다.
session table을 어떻게 만들고 업데이트하고 삭제하는지를 알아야한다.

One armed 방식이 있다.
자기가 최종 호스트인 것 처럼 해서 실제 처리 호스트에게 처리하도록 하는 것
처리 결과도 L4가 받아서 클라이언트에게 돌려준다.

DSR 방식은 direct server return
실제 처리 호스트가 L4 거치지 않고 바로 클라이언트로 응답을 보낸다.
이 방식은 추가적인 작업이 필요하다.
왜냐하면 클라이언트는 L4하고 연결돼있다고(양방향 통신이니까 TCP통신?) 생각하는데 다른 호스트 D에게서 응답이 오면 안 되니까.
그래서 loopback address를 잡아줘야한다. 내보낼 때는 다른 IP로 내보내야한다.L4의 IP로.
또 얘는 arp request에 대해 응답하지 않게 NIL 옵션에서 설정해준다.
arp는 L4에 매겨라.(모르겠다 뭔말인지)

Round robin을 할 수도 있고 hash 방식으로 할 수도 있다.
인증을 이용하는 경우는 RR이 안 좋을 수 있다. 인증을 했는데 그 다음 요청에서 또 다시 인증하라고 할 수 있으니까.

Health check
L3의 ping만 체크할 수 있다. 그런데 얘는 핑은 살아있는데 웹서버의 데몬이 죽어있어서 서비스를 못 하는 상황일 수 있다.
특정 포트가 listen인지 체크할 수도 있다. 근데 특정 페이지가 문제가 있어서 서비스를 못 할 수 있다.
http query로 특정 페이지를 조회해서 체크할 수도 있다. 이건 L7 레벨이다.
